/**
 * SEO Generator - robots.txt
 *
 * robots.txt generation for Alfred projects.
 */

import type { GeneratedRobotsTxt } from '../types';

interface RobotsRule {
  userAgent: string;
  allow?: string[];
  disallow?: string[];
  crawlDelay?: number;
}

interface GenerateRobotsTxtOptions {
  sitemapUrl?: string;
  rules?: RobotsRule[];
  allowAll?: boolean;
  disallowPaths?: string[];
  additionalDirectives?: string[];
}

/**
 * Generate robots.txt content
 */
export function generateRobotsTxt(options: GenerateRobotsTxtOptions = {}): GeneratedRobotsTxt {
  const {
    sitemapUrl,
    rules = [],
    allowAll = true,
    disallowPaths = [],
    additionalDirectives = [],
  } = options;

  const lines: string[] = [
    '# robots.txt - Generated by Alfred SEO Agent',
    `# Generated: ${new Date().toISOString()}`,
    '',
  ];

  const appliedRules: string[] = [];

  // If no custom rules, use default
  if (rules.length === 0) {
    lines.push('User-agent: *');
    appliedRules.push('User-agent: *');

    if (allowAll) {
      lines.push('Allow: /');
      appliedRules.push('Allow: /');
    }

    if (disallowPaths.length > 0) {
      for (const path of disallowPaths) {
        lines.push(`Disallow: ${path}`);
        appliedRules.push(`Disallow: ${path}`);
      }
    }
  } else {
    // Apply custom rules
    for (const rule of rules) {
      lines.push(`User-agent: ${rule.userAgent}`);
      appliedRules.push(`User-agent: ${rule.userAgent}`);

      if (rule.allow) {
        for (const path of rule.allow) {
          lines.push(`Allow: ${path}`);
          appliedRules.push(`Allow: ${path}`);
        }
      }

      if (rule.disallow) {
        for (const path of rule.disallow) {
          lines.push(`Disallow: ${path}`);
          appliedRules.push(`Disallow: ${path}`);
        }
      }

      if (rule.crawlDelay) {
        lines.push(`Crawl-delay: ${rule.crawlDelay}`);
        appliedRules.push(`Crawl-delay: ${rule.crawlDelay}`);
      }

      lines.push('');
    }
  }

  // Add additional directives
  if (additionalDirectives.length > 0) {
    lines.push('');
    lines.push('# Additional directives');
    for (const directive of additionalDirectives) {
      lines.push(directive);
      appliedRules.push(directive);
    }
  }

  // Add sitemap reference
  if (sitemapUrl) {
    lines.push('');
    lines.push(`Sitemap: ${sitemapUrl}`);
    appliedRules.push(`Sitemap: ${sitemapUrl}`);
  }

  return {
    content: lines.join('\n'),
    rules: appliedRules,
  };
}

/**
 * Generate robots.txt for common scenarios
 */
export const robotsPresets = {
  /**
   * Allow all crawling (recommended for most sites)
   */
  allowAll: (sitemapUrl?: string): GeneratedRobotsTxt => {
    return generateRobotsTxt({
      allowAll: true,
      sitemapUrl,
    });
  },

  /**
   * Disallow all crawling (for staging/dev sites)
   */
  disallowAll: (): GeneratedRobotsTxt => {
    return generateRobotsTxt({
      rules: [{
        userAgent: '*',
        disallow: ['/'],
      }],
    });
  },

  /**
   * Allow with common exclusions
   */
  standard: (sitemapUrl?: string): GeneratedRobotsTxt => {
    return generateRobotsTxt({
      allowAll: true,
      sitemapUrl,
      disallowPaths: [
        '/admin/',
        '/api/',
        '/private/',
        '/*.json$',
        '/node_modules/',
      ],
    });
  },

  /**
   * E-commerce optimized
   */
  ecommerce: (sitemapUrl?: string): GeneratedRobotsTxt => {
    return generateRobotsTxt({
      allowAll: true,
      sitemapUrl,
      disallowPaths: [
        '/cart/',
        '/checkout/',
        '/account/',
        '/admin/',
        '/api/',
        '/*?*sort=',
        '/*?*filter=',
        '/*?*page=',
      ],
    });
  },

  /**
   * Blog optimized
   */
  blog: (sitemapUrl?: string): GeneratedRobotsTxt => {
    return generateRobotsTxt({
      allowAll: true,
      sitemapUrl,
      disallowPaths: [
        '/admin/',
        '/wp-admin/',
        '/tag/*',
        '/category/*',
        '/*?*page=',
      ],
    });
  },
};

/**
 * Parse existing robots.txt
 */
export function parseRobotsTxt(content: string): {
  rules: RobotsRule[];
  sitemapUrl?: string;
} {
  const lines = content.split('\n');
  const rules: RobotsRule[] = [];
  let currentRule: RobotsRule | null = null;
  let sitemapUrl: string | undefined;

  for (let line of lines) {
    // Remove comments and trim
    line = line.replace(/#.*$/, '').trim();
    if (!line) continue;

    const [directive, value] = line.split(':').map(s => s.trim());

    switch (directive.toLowerCase()) {
      case 'user-agent':
        if (currentRule) {
          rules.push(currentRule);
        }
        currentRule = {
          userAgent: value,
          allow: [],
          disallow: [],
        };
        break;

      case 'allow':
        if (currentRule) {
          currentRule.allow!.push(value);
        }
        break;

      case 'disallow':
        if (currentRule) {
          currentRule.disallow!.push(value);
        }
        break;

      case 'crawl-delay':
        if (currentRule) {
          currentRule.crawlDelay = parseInt(value, 10);
        }
        break;

      case 'sitemap':
        sitemapUrl = value;
        break;
    }
  }

  if (currentRule) {
    rules.push(currentRule);
  }

  return { rules, sitemapUrl };
}

/**
 * Validate robots.txt
 */
export function validateRobotsTxt(content: string): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  const lines = content.split('\n');
  let hasUserAgent = false;
  let inUserAgentBlock = false;

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].replace(/#.*$/, '').trim();
    if (!line) continue;

    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) {
      errors.push(`Line ${i + 1}: Invalid directive format`);
      continue;
    }

    const directive = line.slice(0, colonIndex).trim().toLowerCase();
    const value = line.slice(colonIndex + 1).trim();

    switch (directive) {
      case 'user-agent':
        hasUserAgent = true;
        inUserAgentBlock = true;
        if (!value) {
          errors.push(`Line ${i + 1}: User-agent value is empty`);
        }
        break;

      case 'allow':
      case 'disallow':
        if (!inUserAgentBlock) {
          warnings.push(`Line ${i + 1}: ${directive} before User-agent`);
        }
        break;

      case 'sitemap':
        if (!value.startsWith('http')) {
          warnings.push(`Line ${i + 1}: Sitemap URL should be absolute`);
        }
        break;

      case 'crawl-delay':
        if (isNaN(parseInt(value, 10))) {
          errors.push(`Line ${i + 1}: Crawl-delay must be a number`);
        }
        break;

      default:
        warnings.push(`Line ${i + 1}: Unknown directive "${directive}"`);
    }
  }

  if (!hasUserAgent) {
    errors.push('No User-agent directive found');
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}
